import{_ as e}from"./chunk-6b313974.js";import{_ as t}from"./chunk-9c6aa90d.js";import{d as s,q as a,r as i,b as n,t as r,U as l,al as d,o as c,c as o,R as u,a as p,J as h,Q as m,a4 as v,O as g,P as f,M as y,I as b,E as x,D as $,aF as w,v as S}from"./chunk-bb5ca2a1.js";import{_ as k}from"../assets/index-2738d5ba.js";import"./chunk-7296d483.js";import"./chunk-c8f53b98.js";import"./chunk-dd4ac5f9.js";const _={class:"flex flex-col mt-3 flex-1"},T={class:"p-6 rounded-2xl bg-white space-y-6"},A={class:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"},R={class:"block text-sm font-medium mb-2"},M={key:0,class:"text-xs text-gray-500"},z={class:"block text-sm font-medium mb-2"},E={class:"flex flex-wrap gap-3"},P={class:"grid grid-cols-2 md:grid-cols-4 gap-4 p-4 bg-gray-50 rounded-lg"},C={class:"text-center"},V={class:"text-2xl font-bold text-blue-600 font-mono"},j={class:"text-center"},D={class:"text-2xl font-bold text-green-600"},I={class:"text-center"},q={class:"text-2xl font-bold text-purple-600"},U={class:"text-center"},W={class:"text-2xl font-bold text-orange-600"},L={key:0,class:"bg-gray-50 p-4 rounded-lg"},B={class:"flex justify-between items-center mb-2"},F={class:"text-sm font-medium"},H={key:0,class:"mt-2 text-sm text-blue-600"},J={class:"bg-gray-50 p-3 sm:p-6 rounded-lg min-h-[350px] sm:min-h-[400px]"},O={class:"overflow-x-auto"},Q={key:0,class:"text-xs text-gray-500 text-center mt-2"},G=k(s({__name:"AlgorithmVisualization",setup(s){const k=a({title:"算法可视化"}),G=[{label:"冒泡排序",value:"bubbleSort"},{label:"选择排序",value:"selectionSort"},{label:"插入排序",value:"insertionSort"},{label:"快速排序",value:"quickSort"},{label:"归并排序",value:"mergeSort"},{label:"堆排序",value:"heapSort"},{label:"希尔排序",value:"shellSort"},{label:"计数排序",value:"countingSort"},{label:"基数排序",value:"radixSort"}],K=a({selectedAlgorithm:"bubbleSort",arraySize:25,animationSpeed:100,isRunning:!1,isPaused:!1,isCompleted:!1,currentStep:0,totalSteps:0,startTime:0,elapsedTime:0,currentRound:0,totalRounds:0,comparisons:0,swaps:0,pausedTime:0,pauseStartTime:0});let N=null;const X=()=>{K.isRunning&&!K.isPaused&&(K.elapsedTime=Date.now()-K.startTime-K.pausedTime)},Y=()=>{N&&(clearInterval(N),N=null)},Z=i([]),ee=i([]),te=i([]),se=n(()=>window.innerWidth<768),ae=n(()=>se.value?15:50),ie=n(()=>{const e=window.innerWidth;return e<640?Math.max(12,Math.floor((e-80)/K.arraySize)):e<768?Math.max(16,Math.floor((e-100)/K.arraySize)):32}),ne=()=>{const e=se.value?15:50;K.arraySize>e&&(K.arraySize=e),Z.value=Array.from({length:K.arraySize},()=>Math.floor(100*Math.random())+1),ee.value=Array(K.arraySize).fill("normal"),K.currentStep=0,K.totalSteps=0,K.isCompleted=!1,K.elapsedTime=0,K.currentRound=0,K.totalRounds=0,K.comparisons=0,K.swaps=0,K.pausedTime=0,K.pauseStartTime=0,te.value=[]},re=(e,t=0,s=e.length-1,a=[],i=0)=>{if(t<s){a.push({type:"round",round:i+1,description:`第 ${i+1} 层递归：处理区间 [${t}, ${s}]`});const n=le(e,t,s,a);a.push({type:"sorted",indices:[n],description:`基准值 ${e[n]} 已放到正确位置 ${n}`}),re(e,t,n-1,a,i+1),re(e,n+1,s,a,i+1),t<n-1?a.push({type:"subsorted",indices:Array.from({length:n-t},(e,s)=>t+s),description:`左子数组 [${t}, ${n-1}] 排序完成`}):t===n-1&&a.push({type:"sorted",indices:[t],description:`元素 ${e[t]} 已排序`}),n+1<s?a.push({type:"subsorted",indices:Array.from({length:s-n},(e,t)=>n+1+t),description:`右子数组 [${n+1}, ${s}] 排序完成`}):n+1===s&&a.push({type:"sorted",indices:[s],description:`元素 ${e[s]} 已排序`})}else t===s&&a.push({type:"sorted",indices:[t],description:`单个元素 ${e[t]} 已排序`});return 0===i&&a.push({type:"complete",indices:Array.from({length:e.length},(e,t)=>t),description:"快速排序完成"}),a},le=(e,t,s,a)=>{const i=e[s];let n=t-1;a.push({type:"pivot",indices:[s],description:`选择 ${i} 作为基准值`});for(let l=t;l<s;l++)if(a.push({type:"compare",indices:[l,s],description:`比较 ${e[l]} 和基准值 ${i}`}),e[l]<i&&(n++,n!==l)){a.push({type:"swap",indices:[n,l],description:`交换 ${e[n]} 和 ${e[l]}`});const t=e[n];e[n]=e[l],e[l]=t}a.push({type:"swap",indices:[n+1,s],description:`将基准值 ${i} 放到正确位置 ${n+1}`});const r=e[n+1];return e[n+1]=e[s],e[s]=r,n+1},de=(e,t=0,s=e.length-1,a=[],i=0)=>{if(t<s){const n=Math.floor((t+s)/2);a.push({type:"round",round:i+1,description:`第 ${i+1} 层递归：分割 [${t}, ${s}]`}),a.push({type:"divide",indices:Array.from({length:s-t+1},(e,s)=>t+s),description:`分割数组 [${t}, ${s}] 为 [${t}, ${n}] 和 [${n+1}, ${s}]`}),de(e,t,n,a,i+1),de(e,n+1,s,a,i+1),ce(e,t,n,s,a)}else a.push({type:"sorted",indices:[t],description:`单个元素 ${e[t]} 已排序`});return 0===i&&a.push({type:"complete",indices:Array.from({length:e.length},(e,t)=>t),description:"归并排序完成"}),a},ce=(e,t,s,a,i)=>{const n=e.slice(t,s+1),r=e.slice(s+1,a+1);i.push({type:"merge",indices:Array.from({length:a-t+1},(e,s)=>t+s),description:`开始合并 [${t}, ${s}] 和 [${s+1}, ${a}]`});let l=0,d=0,c=t;for(;l<n.length&&d<r.length;)i.push({type:"compare",indices:[c],leftValue:n[l],rightValue:r[d],description:`比较 ${n[l]} 和 ${r[d]}`}),n[l]<=r[d]?(e[c]=n[l],i.push({type:"place",indices:[c],value:n[l],description:`将 ${n[l]} 放置到位置 ${c}`}),l++):(e[c]=r[d],i.push({type:"place",indices:[c],value:r[d],description:`将 ${r[d]} 放置到位置 ${c}`}),d++),c++;for(;l<n.length;)e[c]=n[l],i.push({type:"place",indices:[c],value:n[l],description:`将剩余元素 ${n[l]} 放置到位置 ${c}`}),l++,c++;for(;d<r.length;)e[c]=r[d],i.push({type:"place",indices:[c],value:r[d],description:`将剩余元素 ${r[d]} 放置到位置 ${c}`}),d++,c++;i.push({type:"subsorted",indices:Array.from({length:a-t+1},(e,s)=>t+s),description:`区间 [${t}, ${a}] 合并完成`})},oe=(e,t,s,a)=>{let i=s;const n=2*s+1,r=2*s+2;if(a.push({type:"current",indices:[s],description:`调整以位置 ${s} 为根的子堆`}),n<t&&(a.push({type:"compare",indices:[n,i],description:`比较左子节点 ${e[n]} 和当前最大值 ${e[i]}`}),e[n]>e[i]&&(i=n,a.push({type:"newmax",indices:[i],description:`左子节点 ${e[n]} 成为新的最大值`}))),r<t&&(a.push({type:"compare",indices:[r,i],description:`比较右子节点 ${e[r]} 和当前最大值 ${e[i]}`}),e[r]>e[i]&&(i=r,a.push({type:"newmax",indices:[i],description:`右子节点 ${e[r]} 成为新的最大值`}))),i!==s){a.push({type:"swap",indices:[s,i],description:`交换 ${e[s]} 和 ${e[i]} 以维持堆性质`});const n=e[s];e[s]=e[i],e[i]=n,oe(e,t,i,a)}},ue=()=>{const e=[...Z.value];switch(K.selectedAlgorithm){case"bubbleSort":return(e=>{const t=[],s=e.length,a=[...e];let i=0;for(let n=0;n<s-1;n++){i++,t.push({type:"round",round:i,description:`第 ${i} 轮冒泡排序开始`});for(let e=0;e<s-n-1;e++)if(t.push({type:"compare",indices:[e,e+1],description:`比较 ${a[e]} 和 ${a[e+1]}`}),a[e]>a[e+1]){t.push({type:"swap",indices:[e,e+1],description:`交换 ${a[e]} 和 ${a[e+1]}`});const s=a[e];a[e]=a[e+1],a[e+1]=s}t.push({type:"sorted",indices:[s-n-1],description:`位置 ${s-n-1} 已排序完成`})}return t.push({type:"complete",indices:Array.from({length:s},(e,t)=>t),description:"冒泡排序完成"}),t})(e);case"selectionSort":return(e=>{const t=[],s=e.length,a=[...e];let i=0;for(let n=0;n<s-1;n++){i++,t.push({type:"round",round:i,description:`第 ${i} 轮选择排序开始`});let e=n;t.push({type:"current",indices:[n],description:`开始处理位置 ${n}`});for(let i=n+1;i<s;i++)t.push({type:"compare",indices:[e,i],description:`比较 ${a[e]} 和 ${a[i]}`}),a[i]<a[e]&&(e=i,t.push({type:"newmin",indices:[e],description:`找到新的最小值 ${a[e]} 在位置 ${e}`}));if(e!==n){t.push({type:"swap",indices:[n,e],description:`交换 ${a[n]} 和 ${a[e]}`});const s=a[n];a[n]=a[e],a[e]=s}t.push({type:"sorted",indices:[n],description:`位置 ${n} 已排序完成`})}return t.push({type:"sorted",indices:[s-1],description:"排序完成"}),t})(e);case"insertionSort":return(e=>{const t=[],s=e.length,a=[...e];let i=0;for(let n=1;n<s;n++){i++,t.push({type:"round",round:i,description:`第 ${i} 轮插入排序开始`});const e=a[n];let s=n-1;for(t.push({type:"current",indices:[n],description:`处理元素 ${e} 在位置 ${n}`});s>=0&&a[s]>e;)t.push({type:"compare",indices:[s,n],description:`比较 ${a[s]} 和 ${e}`}),t.push({type:"swap",indices:[s,s+1],description:`将 ${a[s]} 向右移动到位置 ${s+1}`}),a[s+1]=a[s],s--;a[s+1]=e,t.push({type:"insert",indices:[s+1],value:e,description:`将 ${e} 插入到位置 ${s+1}`})}return t.push({type:"complete",indices:Array.from({length:s},(e,t)=>t),description:"插入排序完成"}),t})(e);case"quickSort":return re([...e]);case"mergeSort":return de([...e]);case"heapSort":return(e=>{const t=[],s=e.length,a=[...e];let i=0;t.push({type:"round",round:++i,description:"开始构建最大堆"});for(let n=Math.floor(s/2)-1;n>=0;n--)oe(a,s,n,t);t.push({type:"heap_built",indices:Array.from({length:s},(e,t)=>t),description:"最大堆构建完成"});for(let n=s-1;n>0;n--){t.push({type:"round",round:++i,description:`第 ${i-1} 轮：提取堆顶元素`}),t.push({type:"swap",indices:[0,n],description:`将堆顶最大值 ${a[0]} 移到位置 ${n}`});const e=a[0];a[0]=a[n],a[n]=e,t.push({type:"sorted",indices:[n],description:`位置 ${n} 已排序完成`}),oe(a,n,0,t)}return t.push({type:"sorted",indices:[0],description:"最后一个元素已排序"}),t.push({type:"complete",indices:Array.from({length:s},(e,t)=>t),description:"堆排序完成"}),t})(e);case"shellSort":return(e=>{const t=[],s=e.length,a=[...e];let i=0;for(let n=Math.floor(s/2);n>0;n=Math.floor(n/2)){i++,t.push({type:"round",round:i,description:`第 ${i} 轮：间隔为 ${n}`}),t.push({type:"gap_highlight",gap:n,description:`当前间隔: ${n}`});for(let e=n;e<s;e++){const s=a[e];let i=e;for(t.push({type:"current",indices:[e],description:`处理元素 ${s} 在位置 ${e}`});i>=n&&a[i-n]>s;)t.push({type:"compare",indices:[i-n,i],gap:n,description:`比较间隔为${n}的元素: ${a[i-n]} 和 ${s}`}),t.push({type:"swap",indices:[i-n,i],description:`移动 ${a[i-n]} 到位置 ${i}`}),a[i]=a[i-n],i-=n;a[i]=s,i!==e&&t.push({type:"insert",indices:[i],value:s,description:`将 ${s} 插入到位置 ${i}`})}}return t.push({type:"complete",indices:Array.from({length:s},(e,t)=>t),description:"希尔排序完成"}),t})(e);case"countingSort":return(e=>{const t=[],s=e.length,a=[...e],i=Math.max(...a),n=Math.min(...a),r=i-n+1;t.push({type:"round",round:1,description:"第 1 阶段：统计每个元素出现次数"}),t.push({type:"find_range",indices:Array.from({length:s},(e,t)=>t),description:`数组范围: ${n} ~ ${i}，需要 ${r} 个计数桶`});const l=new Array(r).fill(0);for(let c=0;c<s;c++)t.push({type:"counting",indices:[c],value:a[c],countIndex:a[c]-n,description:`统计元素 ${a[c]}，计数桶[${a[c]-n}] += 1`}),l[a[c]-n]++;t.push({type:"count_complete",indices:[],countArray:[...l],description:"统计完成，开始重建数组"}),t.push({type:"round",round:2,description:"第 2 阶段：根据计数重建有序数组"});let d=0;for(let c=0;c<r;c++)for(;l[c]>0;)t.push({type:"rebuild",indices:[d],value:c+n,countIndex:c,description:`从计数桶[${c}]取出 ${c+n} 放到位置 ${d}`}),a[d]=c+n,l[c]--,d++;return t.push({type:"complete",indices:Array.from({length:s},(e,t)=>t),description:"计数排序完成"}),t})(e);case"radixSort":return(e=>{const t=[],s=e.length,a=[...e],i=Math.max(...a),n=i.toString().length;t.push({type:"find_digits",indices:Array.from({length:s},(e,t)=>t),description:`最大值 ${i} 有 ${n} 位，需要进行 ${n} 轮排序`});for(let r=0;r<n;r++){const e=Math.pow(10,r);t.push({type:"round",round:r+1,description:`第 ${r+1} 轮：按第 ${r+1} 位（${0===r?"个":1===r?"十":2===r?"百":r+1}位）排序`});for(let l=0;l<s;l++){const s=Math.floor(a[l]/e)%10;t.push({type:"show_digit",indices:[l],digit:s,digitPosition:r+1,description:`${a[l]} 的第 ${r+1} 位是 ${s}`})}const i=Array.from({length:10},()=>[]);for(let r=0;r<s;r++){const s=Math.floor(a[r]/e)%10;i[s].push(a[r]),t.push({type:"bucket_assign",indices:[r],value:a[r],bucket:s,description:`将 ${a[r]} 放入桶 ${s}`})}let n=0;for(let s=0;s<10;s++)for(let e=0;e<i[s].length;e++)t.push({type:"bucket_collect",indices:[n],value:i[s][e],bucket:s,description:`从桶 ${s} 收集 ${i[s][e]} 到位置 ${n}`}),a[n]=i[s][e],n++;t.push({type:"digit_complete",indices:Array.from({length:s},(e,t)=>t),description:`第 ${r+1} 位排序完成`})}return t.push({type:"complete",indices:Array.from({length:s},(e,t)=>t),description:"基数排序完成"}),t})(e);default:return[]}},pe=e=>{switch(e.type){case"compare":K.comparisons++;break;case"swap":case"move":case"rebuild":case"bucket_assign":case"bucket_collect":case"place":K.swaps++;break;case"round":K.currentRound=e.round||K.currentRound}const t=ee.value.map((e,t)=>"sorted"===e?t:-1).filter(e=>-1!==e);ee.value=Array(Z.value.length).fill("normal"),t.forEach(e=>{ee.value[e]="sorted"});const s=e.indices||[];switch(e.type){case"compare":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="comparing")});break;case"swap":if(s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="swapping")}),2===s.length){const[e,t]=s,a=Z.value[e];Z.value[e]=Z.value[t],Z.value[t]=a}break;case"gap_highlight":if(e.gap)for(let t=0;t<Z.value.length;t+=e.gap)"sorted"!==ee.value[t]&&(ee.value[t]="gap_highlight");break;case"find_range":case"find_digits":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="analyzing")});break;case"counting":s.forEach(e=>{ee.value[e]="counting"});break;case"count_complete":ee.value.fill("analyzing");break;case"rebuild":s.forEach(e=>{ee.value[e]="rebuilding"}),void 0!==e.value&&1===s.length&&(Z.value[s[0]]=e.value);break;case"show_digit":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="digit_highlight")});break;case"bucket_assign":s.forEach(e=>{ee.value[e]="bucket_assign"});break;case"bucket_collect":s.forEach(e=>{ee.value[e]="bucket_collect"}),void 0!==e.value&&1===s.length&&(Z.value[s[0]]=e.value);break;case"insert":s.forEach(e=>{ee.value[e]="inserting"}),void 0!==e.value&&1===s.length&&(Z.value[s[0]]=e.value);break;case"place":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="placing")}),void 0!==e.value&&1===s.length&&(Z.value[s[0]]=e.value);break;case"sorted":case"subsorted":case"digit_complete":case"complete":s.forEach(e=>{ee.value[e]="sorted"});break;case"pivot":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="pivot")});break;case"current":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="current")});break;case"newmin":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="newmin")});break;case"newmax":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="newmax")});break;case"divide":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="dividing")});break;case"merge":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="merging")});break;case"heap_built":s.forEach(e=>{"sorted"!==ee.value[e]&&(ee.value[e]="heap")})}},he=()=>{return e=this,t=null,s=function*(){if(!K.isRunning){K.isCompleted&&ne(),K.isRunning=!0,K.isPaused=!1,K.isCompleted=!1,K.currentStep=0,K.startTime=Date.now(),K.elapsedTime=0,K.currentRound=0,K.comparisons=0,K.swaps=0,K.pausedTime=0,K.pauseStartTime=0,te.value=ue(),K.totalSteps=te.value.length,K.totalRounds=((e,t)=>{switch(e){case"bubbleSort":case"selectionSort":case"insertionSort":return t-1;case"quickSort":case"mergeSort":case"heapSort":return Math.ceil(Math.log2(t));default:return 0}})(K.selectedAlgorithm,Z.value.length),N&&clearInterval(N),N=setInterval(X,50);for(let e=0;e<te.value.length&&K.isRunning;e++){for(;K.isPaused;)0===K.pauseStartTime&&(K.pauseStartTime=Date.now()),yield new Promise(e=>setTimeout(e,100));K.pauseStartTime>0&&(K.pausedTime+=Date.now()-K.pauseStartTime,K.pauseStartTime=0),K.currentStep=e+1,pe(te.value[e]),yield new Promise(e=>setTimeout(e,1e3-10*K.animationSpeed))}Y(),K.elapsedTime=Date.now()-K.startTime-K.pausedTime,K.isRunning=!1,K.isCompleted=!0}},new Promise((a,i)=>{var n=e=>{try{l(s.next(e))}catch(t){i(t)}},r=e=>{try{l(s.throw(e))}catch(t){i(t)}},l=e=>e.done?a(e.value):Promise.resolve(e.value).then(n,r);l((s=s.apply(e,t)).next())});var e,t,s},me=()=>{K.isPaused?(K.pauseStartTime>0&&(K.pausedTime+=Date.now()-K.pauseStartTime,K.pauseStartTime=0),K.isPaused=!1):(K.pauseStartTime=Date.now(),K.isPaused=!0)},ve=()=>{Y(),K.isRunning=!1,K.isPaused=!1,K.isCompleted=!1,Y(),K.isRunning=!1,K.isPaused=!1,K.isCompleted=!1,K.currentStep=0,K.elapsedTime=0,K.currentRound=0,K.comparisons=0,K.swaps=0,K.pausedTime=0,K.pauseStartTime=0,ee.value=Array(Z.value.length).fill("normal")},ge=e=>{switch(ee.value[e]){case"comparing":return"#3b82f6";case"swapping":return"#ef4444";case"sorted":case"rebuilding":return"#10b981";case"pivot":case"gap_highlight":return"#8b5cf6";case"current":case"analyzing":return"#06b6d4";case"newmin":case"bucket_assign":return"#f97316";case"newmax":return"#dc2626";case"moving":case"digit_highlight":return"#ec4899";case"inserting":return"#84cc16";case"dividing":return"#a855f7";case"merging":return"#0ea5e9";case"placing":case"bucket_collect":return"#22c55e";case"heap":case"counting":return"#f59e0b";default:return"#e5e7eb"}},fe=()=>{var e;return K.currentStep>0&&K.currentStep<=te.value.length&&(null==(e=te.value[K.currentStep-1])?void 0:e.description)||""},ye=n(()=>K.isRunning?"演示中...":K.isCompleted?"重新演示":"开始演示");return r(()=>{ne();const e=()=>{S(()=>{se.value&&K.arraySize>15&&(K.arraySize=15,ne())})};window.addEventListener("resize",e),l(()=>{window.removeEventListener("resize",e)})}),l(()=>{Y()}),(s,a)=>{const i=d("el-option"),n=d("el-select"),r=d("el-slider"),l=d("el-button"),S=d("el-progress");return c(),o("div",_,[u(e,{title:k.title},null,8,["title"]),p("div",T,[p("div",A,[p("div",null,[a[3]||(a[3]=p("label",{class:"block text-sm font-medium mb-2"},"算法类型",-1)),u(n,{modelValue:K.selectedAlgorithm,"onUpdate:modelValue":a[0]||(a[0]=e=>K.selectedAlgorithm=e),disabled:K.isRunning,class:"w-full"},{default:h(()=>[(c(),o(m,null,v(G,e=>u(i,{key:e.value,label:e.label,value:e.value},null,8,["label","value"])),64))]),_:1},8,["modelValue","disabled"])]),p("div",null,[p("label",R,[g(" 数组大小: "+f(K.arraySize)+" ",1),se.value?(c(),o("span",M,"(手机端最大15)")):y("",!0)]),u(r,{modelValue:K.arraySize,"onUpdate:modelValue":a[1]||(a[1]=e=>K.arraySize=e),min:5,max:ae.value,disabled:K.isRunning,"show-tooltip":!1,onChange:ne},null,8,["modelValue","max","disabled"])]),p("div",null,[p("label",z,"动画速度: "+f(K.animationSpeed)+"%",1),u(r,{modelValue:K.animationSpeed,"onUpdate:modelValue":a[2]||(a[2]=e=>K.animationSpeed=e),min:1,max:100,"show-tooltip":!1},null,8,["modelValue"])])]),p("div",E,[u(l,{type:"primary",onClick:he,disabled:K.isRunning,loading:K.isRunning},{default:h(()=>[g(f(ye.value),1)]),_:1},8,["disabled","loading"]),K.isRunning?(c(),b(l,{key:0,onClick:me},{default:h(()=>[g(f(K.isPaused?"继续":"暂停"),1)]),_:1})):y("",!0),u(l,{onClick:ve,disabled:!K.isRunning&&!K.isCompleted},{default:h(()=>a[4]||(a[4]=[g(" 停止 ",-1)])),_:1,__:[4]},8,["disabled"]),u(l,{onClick:ne,disabled:K.isRunning},{default:h(()=>a[5]||(a[5]=[g(" 生成新数组 ",-1)])),_:1,__:[5]},8,["disabled"])]),p("div",P,[p("div",C,[p("div",V,f((N=K.elapsedTime,`${Math.floor(N/1e3)}.${Math.floor(N%1e3/10).toString().padStart(2,"0")}s`)),1),a[6]||(a[6]=p("div",{class:"text-sm text-gray-600"},"执行时间",-1))]),p("div",j,[p("div",D,f(K.currentRound)+" / "+f(K.totalRounds),1),a[7]||(a[7]=p("div",{class:"text-sm text-gray-600"},"当前轮数",-1))]),p("div",I,[p("div",q,f(K.comparisons),1),a[8]||(a[8]=p("div",{class:"text-sm text-gray-600"},"比较次数",-1))]),p("div",U,[p("div",W,f(K.swaps),1),a[9]||(a[9]=p("div",{class:"text-sm text-gray-600"},"交换次数",-1))])]),K.totalSteps>0?(c(),o("div",L,[p("div",B,[p("span",F,"步骤进度: "+f(K.currentStep)+" / "+f(K.totalSteps),1)]),u(S,{percentage:Math.round(K.currentStep/K.totalSteps*100)},null,8,["percentage"]),fe()?(c(),o("div",H,f(fe()),1)):y("",!0)])):y("",!0),p("div",J,[p("div",O,[p("div",{class:"flex items-end justify-center space-x-1 h-64 sm:h-80 min-w-full",style:x({minWidth:`${Math.max(320,K.arraySize*(ie.value+4))}px`})},[(c(!0),o(m,null,v(Z.value,(e,t)=>(c(),o("div",{key:t,class:"flex flex-col items-center transition-all duration-300 flex-shrink-0"},[p("div",{class:$(["text-xs mb-1 font-mono",{"text-[10px]":se.value&&K.arraySize>10}])},f(e),3),p("div",{class:"transition-all duration-300 rounded-t-sm",style:x({width:`${ie.value}px`,height:e/100*(se.value?200:250)+"px",backgroundColor:ge(t),minHeight:"15px"})},null,4),p("div",{class:$(["text-xs mt-1 text-gray-500",{"text-[10px]":se.value&&K.arraySize>10}])},f(t),3)]))),128))],4)]),se.value&&K.arraySize>10?(c(),o("div",Q," 💡 可以左右滑动查看完整图表 ")):y("",!0)]),a[10]||(a[10]=w('<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-10 gap-2 sm:gap-3 text-xs sm:text-sm" data-v-0b1dd98d><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-gray-300 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>未处理</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-blue-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>比较中</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-red-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>交换中</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-green-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>已排序</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-purple-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>基准值/间隔</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-cyan-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>当前处理</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-orange-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>计数/分桶</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-yellow-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>统计中</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-pink-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>数位高亮</span></div><div class="flex items-center space-x-1 sm:space-x-2" data-v-0b1dd98d><div class="w-3 h-3 sm:w-4 sm:h-4 bg-lime-500 rounded flex-shrink-0" data-v-0b1dd98d></div><span class="truncate" data-v-0b1dd98d>重建/收集</span></div></div>',1))]),u(t,{title:"功能说明"},{default:h(()=>a[11]||(a[11]=[p("div",{class:"space-y-4"},[p("div",null,[p("h4",{class:"font-medium mb-2"},"支持的排序算法："),p("ul",{class:"list-disc list-inside space-y-1 text-sm text-gray-600"},[p("li",null,[p("strong",null,"冒泡排序："),g('通过重复遍历数组，比较相邻元素并交换，将最大元素"冒泡"到末尾')]),p("li",null,[p("strong",null,"选择排序："),g("每次选择未排序部分的最小元素，放到已排序部分的末尾")]),p("li",null,[p("strong",null,"插入排序："),g("将元素逐个插入到已排序部分的正确位置")]),p("li",null,[p("strong",null,"快速排序："),g("选择基准值，将数组分为小于和大于基准值的两部分，递归排序")]),p("li",null,[p("strong",null,"归并排序："),g("将数组分为两半，分别排序后合并")]),p("li",null,[p("strong",null,"堆排序："),g("构建最大堆，重复提取最大元素")]),p("li",null,[p("strong",null,"希尔排序："),g("改进的插入排序，通过间隔序列进行多轮插入排序")]),p("li",null,[p("strong",null,"计数排序："),g("统计每个元素出现次数，然后重建有序数组（非比较排序）")]),p("li",null,[p("strong",null,"基数排序："),g("按数位进行多轮计数排序，从低位到高位依次排序")])])]),p("div",null,[p("h4",{class:"font-medium mb-2"},"使用说明："),p("ul",{class:"list-disc list-inside space-y-1 text-sm text-gray-600"},[p("li",null,"选择要演示的排序算法"),p("li",null,"调整数组大小和动画速度"),p("li",null,'点击"开始演示"观看算法执行过程'),p("li",null,"可以随时暂停、继续或停止演示"),p("li",null,"不同颜色表示元素的不同状态"),p("li",null,"实时显示执行时间、轮数、比较次数和交换次数")])])],-1)])),_:1,__:[11]})]);var N}}}),[["__scopeId","data-v-0b1dd98d"]]);export{G as default};
